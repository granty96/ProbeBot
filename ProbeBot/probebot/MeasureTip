import cv2
import numpy as np

# Load the TIFF image
image = cv2.imread('afm_probe_image.tif', cv2.IMREAD_GRAYSCALE)

# Define the region of interest (ROI) to exclude the bottom info bar
roi = image[:-50, :]

# Extracted scale information (200 nm spans from x-coordinates 608 to 688)
scale_width_pixels = 688 - 608 + 1  # Width of the scale in pixels
scale_width_nm = 200  # Width of the scale in nanometers

# Calculate nanometers per pixel
nm_per_pixel = scale_width_nm / scale_width_pixels

# Preprocessing
# Apply Gaussian blur for noise reduction
image_blurred = cv2.GaussianBlur(roi, (5, 5), 0)

# Edge Detection
edges = cv2.Canny(image_blurred, 30, 150)

# Find contours
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Find the contour with the largest area (probe tip)
largest_contour = max(contours, key=cv2.contourArea)

# Fit a convex hull to the largest contour
hull = cv2.convexHull(largest_contour)

# Get the vertices of the convex hull
vertices = hull[:, 0]

# Draw the polygon (convex hull) on the image
polygon_image = cv2.cvtColor(roi, cv2.COLOR_GRAY2BGR)  # Convert to color image for visualization
cv2.polylines(polygon_image, [vertices], isClosed=True, color=(0, 255, 0), thickness=2)  # Draw the polygon in green with thickness 2

# Display the image with the drawn polygon
cv2.imshow('Image with Polygon (Probe Tip)', polygon_image)
cv2.waitKey(0)
cv2.destroyAllWindows()

# Calculate the distances between adjacent vertices
distances = np.linalg.norm(np.diff(vertices, axis=0), axis=1)

# Identify the shortest distance as the diameter of the tip
diameter = np.min(distances)

# Convert the diameter to nanometers using the scale
diameter_nm = diameter * nm_per_pixel
print("Probe Tip Diameter (in nanometers):", diameter_nm)